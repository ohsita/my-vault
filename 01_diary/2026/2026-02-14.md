---
tags:
  - diary
---
> [!IMPORTANT]
> このテンプレート[[01_diary]]の内容（TODOやTimeline）はサンプルです。
> ご自分にとって使いやすいように編集してください。

## TODO

- [ ] task A
- [ ] task B

## Timeline
別のUbuntuマシン（リモート機）にあるカメラの映像を、手元のWSLマシン（ローカル機）で動作する「Karura Science Dashboard」に表示させるための、詳細な作業レポートを作成しました。

このレポートは、**1. ローカル環境の再構築（ブランチ切り替え含む）**、**2. リモート環境のセットアップ（SSH経由）**、**3. 接続と実行** の3部構成になっています。

---

# 作業レポート：リモートマシンの映像をGUIに投影する手順

## 前提条件

- **ローカル機 (手元)**: WSL 2 (Ubuntu 22.04), ROS 2 Humbleインストール済み。
    
- **リモート機 (ロボット側)**: Ubuntu 22.04, ROS 2 Humbleインストール済み, USBカメラ接続済み。
    
- **ネットワーク**: 両方のマシンが同じLAN内にあり、Pingが通ること。
    

---

## Phase 1: ローカル機（WSL）での準備

まず、手元のマシンで正しいコードを取得し、実行環境を整えます。

### 1-1. リポジトリの取得とブランチの切り替え

以前の操作でフォルダ構成が複雑になっている可能性があるため、ホームディレクトリからやり直す手順です。

1. **ホームディレクトリへ移動**:
    Bash
    ```
    cd ~
    ```
2. **クローン（複製）**:
    
    ディレクトリ指定のエラーを防ぐため、リポジトリのルートURLを使用します。
    
    Bash
    
    ```
    git clone https://github.com/KARURA-project/CS2026.git
    ```
    
3. **ディレクトリ移動**:
    
    Bash
    
    ```
    cd CS2026
    ```
    
4. **ブランチの確認と切り替え**:
    
    Science UIの機能が含まれる `feat/science-ui` ブランチに切り替えます。
    
    Bash
    
    ```
    # リモートの全ブランチ情報を取得
    git fetch --all
    
    # 目的のブランチにチェックアウト（切り替え）
    git checkout feat/science-ui
    ```
    
    _※ 成功すると `Switched to branch 'feat/science-ui'` と表示されます。_
    
5. **GUIのフォルダへ移動**:
    
    Bash
    
    ```
    cd karura_gui
    ```
    

### 1-2. Python実行環境の構築

依存関係を隔離するため、仮想環境を新しく作ります。

Bash

```
# 1. 仮想環境の作成
python3 -m venv venv_humble

# 2. 有効化
source venv_humble/bin/activate

# 3. 必須ライブラリのインストール
pip install PySide6 Phidget22 numpy netifaces
```

### 1-3. 通信設定 (重要: Cyclone DDS)

WSL 2と外部マシン間の通信を安定させるため、標準のDDS（通信ミドルウェア）を変更します。

Bash

```
# インストール
sudo apt update
sudo apt install ros-humble-rmw-cyclonedds-cpp

# 設定の適用（このターミナルで有効化）
export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp
export ROS_DOMAIN_ID=0  # 0以外の数字を使う場合はリモート機と合わせる
```

---

## Phase 2: リモート機（Ubuntu）での準備

SSHを使ってリモート機に入り、カメラ映像を配信する設定を行います。

### 2-1. SSH接続

WSLの新しいターミナルウィンドウを開き、以下を実行します。

Bash

```
ssh <リモート機のユーザー名>@<リモート機のIPアドレス>
# 例: ssh karura@192.168.1.100
```

### 2-2. 環境セットアップ

リモート機側でも通信設定を合わせる必要があります。

Bash

```
# ROS 2環境の読み込み
source /opt/ros/humble/setup.bash

# 通信設定（ローカル機と全く同じにする）
export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp
export ROS_DOMAIN_ID=0

# Cyclone DDSのインストール（まだ入っていなければ）
sudo apt update
sudo apt install ros-humble-rmw-cyclonedds-cpp
```

### 2-3. カメラドライバの準備

カメラ映像をROSトピックとして配信するノード（`usb_cam`）をインストールします。

Bash

```
sudo apt install ros-humble-usb-cam
```

---

## Phase 3: 実行と投影

準備が整いました。映像を配信し、GUIで受信します。

### 3-1. リモート機：映像配信の開始

SSH接続しているターミナルで、以下のコマンドを実行します。

これにより、カメラ映像が `/karura/science/camera_down/image_raw` という名前でネットワークに流れます。

Bash

```
ros2 run usb_cam usb_cam_node_exe --ros-args \
    -p video_device:=/dev/video0 \
    -r image_raw:=/karura/science/camera_down/image_raw
```

- `/dev/video0` でエラーが出る場合は、`ls /dev/video*` でデバイス番号を確認して変更してください。
    
- 実行したまま（ログが出ている状態）にしておきます。
    

### 3-2. ローカル機：GUIの起動

WSLのターミナル（Phase 1で設定したもの）に戻り、GUIを起動します。

**注意点**: 必ず `PYTHONPATH` を設定してから起動してください。

Bash

```
# パスを通す（毎回必要）
export PYTHONPATH=$PYTHONPATH:$(pwd)/src

# GUI起動
python3 src/dashboard/main_science.py
```

### 3-3. 確認

GUIが立ち上がったら、画面下部の **"Downward"** と書かれた枠を見てください。

通信が成功していれば、リモート機のカメラ映像がここにリアルタイムで表示されます。

---

## トラブルシューティング

もし映像が映らない場合は、以下の点を確認してください。

1. **Windowsファイアウォール**:
    
    - 初めて `python` を実行した際にファイアウォールの警告が出た場合、「アクセスを許可する」を押しましたか？
        
    - 設定画面の「ファイアウォールとネットワーク保護」→「アプリによる許可」で、`python` 関連の通信（特にプライベートネットワーク）が許可されているか確認してください。
        
2. **トピックの確認**:
    
    - ローカル機で新しいターミナルを開き、設定（`source /opt/ros/humble/setup.bash`, `export RMW...`, `export ROS_DOMAIN_ID...`）を行った後、以下を実行します。
        
        Bash
        
        ```
        ros2 topic list
        ```
        
    - ここに `/karura/science/camera_down/image_raw` が表示されていれば、データは届いています。表示されない場合はネットワーク設定を見直してください。
        
3. **IPアドレスの確認**:
    
    - WSL 2のIPアドレスとリモート機のIPアドレスが、通信可能な範囲にあるか確認してください（通常はCyclone DDSがこの壁を越える助けになります）。


## 四分割&実装
"Downward" ビューのカメラ映像枠を4分割し、それぞれ異なるトピックの映像を表示させるための修正手順を解説します。

主に3つのファイル（`widgets.py`, `science_node.py`, `window.py`）を変更します。

### ステップ 1: 4分割用ウィジェットの作成 (`widgets.py`)

まず、既存のカメラ表示用ウィジェットを4つ並べるための新しいコンテナクラスを作成します。

`karura_gui/src/dashboard/science/widgets.py` を開き、以下のクラスを追加してください。

※ 既存のカメラ表示クラス名が `VideoLabel` や `CameraWidget` であると仮定します。ファイル内の既存クラスを確認して適宜置き換えてください（ここでは `CameraWidget` とします）。

Python

```
# src/dashboard/science/widgets.py の末尾などに追加

from PySide6.QtWidgets import QWidget, QGridLayout, QLabel
# 既存のインポートに加えてこれらが必要

class QuadCameraWidget(QWidget):
    """4つのカメラ映像をグリッド表示するウィジェット"""
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # 2x2のグリッドレイアウトを作成
        layout = QGridLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(2)

        # 4つのカメラ表示枠を作成 (既存のクラスを使用)
        self.cam1 = QLabel("No Signal 1") # または既存の CameraWidget()
        self.cam2 = QLabel("No Signal 2")
        self.cam3 = QLabel("No Signal 3")
        self.cam4 = QLabel("No Signal 4")

        # スタイル調整（枠線など）
        for cam in [self.cam1, self.cam2, self.cam3, self.cam4]:
            cam.setStyleSheet("background-color: black; color: white; border: 1px solid gray;")
            cam.setScaledContents(True) # QLabelの場合

        # レイアウトに配置
        layout.addWidget(self.cam1, 0, 0) # 左上
        layout.addWidget(self.cam2, 0, 1) # 右上
        layout.addWidget(self.cam3, 1, 0) # 左下
        layout.addWidget(self.cam4, 1, 1) # 右下

    # 各枠を更新するメソッド（データを受け取って表示）
    def update_cam1(self, image_data):
        self._update_label(self.cam1, image_data)

    def update_cam2(self, image_data):
        self._update_label(self.cam2, image_data)

    def update_cam3(self, image_data):
        self._update_label(self.cam3, image_data)

    def update_cam4(self, image_data):
        self._update_label(self.cam4, image_data)

    def _update_label(self, label, image_data):
        # ここにROS画像データ(numpy等)をQPixmapに変換してセットする処理を書く
        # ※既存のCameraWidgetがあれば、その update メソッドを呼ぶだけでOKです
        pass 
```

### ステップ 2: ROSノードの拡張 (`science_node.py`)

バックエンドで新たな3つのカメトピックを購読（サブスクライブ）するように変更します。

`karura_gui/src/dashboard/backend/science_node.py` を編集します。

Python

```
# src/dashboard/backend/science_node.py

from PySide6.QtCore import Signal
from sensor_msgs.msg import Image
# ... 他のインポート

class ScienceNode(BaseNode): # クラス名は確認してください
    # シグナルを定義（GUIスレッドへデータを送るため）
    # 既存のシグナルに加えて以下を追加
    camera_signal_1 = Signal(object) # 既存のものがあればそれを使用
    camera_signal_2 = Signal(object)
    camera_signal_3 = Signal(object)
    camera_signal_4 = Signal(object)

    def __init__(self):
        super().__init__('science_node')
        
        # 既存のサブスクライバー
        self.sub_cam1 = self.create_subscription(
            Image, '/karura/science/camera_down/image_raw', self.callback_cam1, 10)

        # ★追加: 新しいカメラ用サブスクライバー
        self.sub_cam2 = self.create_subscription(
            Image, '/karura/science/camera_down/cam2/image_raw', self.callback_cam2, 10)
        
        self.sub_cam3 = self.create_subscription(
            Image, '/karura/science/camera_down/cam3/image_raw', self.callback_cam3, 10)
            
        self.sub_cam4 = self.create_subscription(
            Image, '/karura/science/camera_down/cam4/image_raw', self.callback_cam4, 10)

    # コールバック関数
    def callback_cam1(self, msg):
        self.camera_signal_1.emit(msg) # 画像変換処理が必要ならここで行う

    def callback_cam2(self, msg):
        self.camera_signal_2.emit(msg)

    def callback_cam3(self, msg):
        self.camera_signal_3.emit(msg)

    def callback_cam4(self, msg):
        self.camera_signal_4.emit(msg)
```

### ステップ 3: ウィンドウへの配置と接続 (`window.py`)

最後に、メインウィンドウで新しいウィジェットを使い、シグナルを接続します。

`karura_gui/src/dashboard/science/window.py` を編集します。

Python

```
# src/dashboard/science/window.py

from .widgets import QuadCameraWidget # 作成したクラスをインポート

class ScienceMainWindow(QMainWindow):
    def __init__(self, node):
        super().__init__()
        # ... (省略) ...

        # ★変更: 既存のカメラウィジェットの代わりに QuadCameraWidget を作成
        # self.camera_view = CameraWidget()  <-- これを削除またはコメントアウト
        self.camera_view = QuadCameraWidget() 

        # レイアウトへの追加 (場所は既存のコードに合わせてください)
        # layout.addWidget(self.camera_view) 

        # ★接続: ノードからのシグナルをウィジェットのスロットに繋ぐ
        node.camera_signal_1.connect(self.camera_view.update_cam1)
        node.camera_signal_2.connect(self.camera_view.update_cam2)
        node.camera_signal_3.connect(self.camera_view.update_cam3)
        node.camera_signal_4.connect(self.camera_view.update_cam4)
```

### 実行確認

1. 上記を変更してGUIを起動します。
    
2. 「Downward」タブのカメラ枠が4つに分割されていることを確認します。
    
3. 別のターミナルから、それぞれのトピック名で映像を配信してテストします。
    
    Bash
    
    ```
    # カメラ1 (左上)
    ros2 run usb_cam usb_cam_node_exe --ros-args -r image_raw:=/karura/science/camera_down/image_raw
    
    # カメラ2 (右上)
    ros2 run usb_cam usb_cam_node_exe --ros-args -r image_raw:=/karura/science/camera_down/cam2/image_raw
    ```
    

これで、最大4台のカメラ映像を同時に監視できるようになります。